---
source: protomon-derive/src/lib.rs
expression: format_tokens(output)
---
impl protomon::codec::ProtoType for Message {
    const WIRE_TYPE: protomon::wire::WireType = protomon::wire::WireType::Len;
}
impl protomon::codec::ProtoMessage for Message {
    #[inline(always)]
    fn decode_message_into(
        buf: bytes::Bytes,
        dst: &mut Self,
    ) -> Result<(), protomon::error::DecodeError> {
        use bytes::Buf;
        use protomon::codec::ProtoDecode;
        use protomon::wire::{decode_key, skip_field};
        let original_len = buf.len();
        let mut buf = buf;
        protomon::codec::ProtoRepeated::init_repeated(&mut dst.values, &buf, 2u32);
        while buf.has_remaining() {
            let (wire_type, tag) = decode_key(&mut buf)?.into_parts();
            let value_offset = original_len - buf.remaining();
            match tag {
                1u32 => {
                    <String as protomon::codec::ProtoDecode>::decode_into(
                        &mut buf,
                        &mut dst.name,
                        value_offset,
                    )?
                }
                2u32 => {
                    protomon::codec::decode_repeated_into::<
                        i32,
                        _,
                    >(wire_type, &mut buf, &mut dst.values, value_offset)?
                }
                _ => skip_field(wire_type, &mut buf)?,
            }
        }
        Ok(())
    }
    fn encode_message<B: bytes::BufMut>(&self, buf: &mut B) {
        if !<String as protomon::codec::IsProtoDefault>::is_proto_default(&self.name) {
            protomon::wire::encode_key(
                <String as protomon::codec::ProtoType>::WIRE_TYPE,
                1u32,
                buf,
            );
            <String as protomon::codec::ProtoEncode>::encode(&self.name, buf);
        }
        protomon::codec::ProtoRepeated::encode_repeated(&self.values, 2u32, buf);
    }
    fn encoded_message_len(&self) -> usize {
        let mut len = 0usize;
        if !<String as protomon::codec::IsProtoDefault>::is_proto_default(&self.name) {
            len
                += protomon::wire::encoded_key_len(1u32)
                    + <String as protomon::codec::ProtoEncode>::encoded_len(&self.name);
        }
        len += protomon::codec::ProtoRepeated::encoded_repeated_len(&self.values, 2u32);
        len
    }
}
impl protomon::codec::ProtoDecode for Message {
    #[inline(always)]
    fn decode_into<B: bytes::Buf>(
        buf: &mut B,
        dst: &mut Self,
        _offset: usize,
    ) -> Result<(), protomon::error::DecodeError> {
        use bytes::Buf;
        let len = protomon::wire::decode_len(buf)?;
        if buf.remaining() < len {
            return Err(protomon::error::DecodeError::unexpected_end_of_buffer());
        }
        <Self as protomon::codec::ProtoMessage>::decode_message_into(
            buf.copy_to_bytes(len),
            dst,
        )?;
        Ok(())
    }
}
impl protomon::codec::ProtoEncode for Message {
    #[inline]
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) {
        use protomon::leb128::LebCodec;
        let len = <Self as protomon::codec::ProtoMessage>::encoded_message_len(self);
        (len as u64).encode_leb128(buf);
        <Self as protomon::codec::ProtoMessage>::encode_message(self, buf);
    }
    #[inline]
    fn encoded_len(&self) -> usize {
        use protomon::leb128::LebCodec;
        let len = <Self as protomon::codec::ProtoMessage>::encoded_message_len(self);
        (len as u64).encoded_leb128_len() + len
    }
}
