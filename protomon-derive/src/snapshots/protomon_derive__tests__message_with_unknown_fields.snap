---
source: protomon-derive/src/lib.rs
expression: format_tokens(output)
---
impl protomon::codec::ProtoType for Message {
    const WIRE_TYPE: protomon::wire::WireType = protomon::wire::WireType::Len;
}
impl protomon::codec::ProtoMessage for Message {
    #[inline(always)]
    fn decode_message_into(
        buf: bytes::Bytes,
        dst: &mut Self,
    ) -> Result<(), protomon::error::DecodeError> {
        use bytes::Buf;
        use protomon::codec::ProtoDecode;
        use protomon::wire::{decode_key, skip_field};
        let original_buf = buf.clone();
        let original_len = buf.len();
        let mut buf = buf;
        use alloc::vec::Vec;
        let mut unknown_buf = Vec::new();
        while buf.has_remaining() {
            let (wire_type, tag) = decode_key(&mut buf)?.into_parts();
            let value_offset = original_len - buf.remaining();
            match tag {
                1u32 => {
                    <i32 as protomon::codec::ProtoDecode>::decode_into(
                        &mut buf,
                        &mut dst.known_field,
                        value_offset,
                    )?
                }
                _ => {
                    use protomon::leb128::LebCodec;
                    let key = (tag << 3) | wire_type as u32;
                    key.encode_leb128(&mut unknown_buf);
                    let value_start = original_len - buf.remaining();
                    skip_field(wire_type, &mut buf)?;
                    let value_end = original_len - buf.remaining();
                    unknown_buf.extend_from_slice(&original_buf[value_start..value_end]);
                }
            }
        }
        dst.unknown_fields = bytes::Bytes::from(unknown_buf);
        Ok(())
    }
    fn encode_message<B: bytes::BufMut>(&self, buf: &mut B) {
        if !<i32 as protomon::codec::IsProtoDefault>::is_proto_default(
            &self.known_field,
        ) {
            protomon::wire::encode_key(
                <i32 as protomon::codec::ProtoType>::WIRE_TYPE,
                1u32,
                buf,
            );
            <i32 as protomon::codec::ProtoEncode>::encode(&self.known_field, buf);
        }
        if !self.unknown_fields.is_empty() {
            use bytes::Buf;
            buf.put_slice(&self.unknown_fields);
        }
    }
    fn encoded_message_len(&self) -> usize {
        let mut len = 0usize;
        if !<i32 as protomon::codec::IsProtoDefault>::is_proto_default(
            &self.known_field,
        ) {
            len
                += protomon::wire::encoded_key_len(1u32)
                    + <i32 as protomon::codec::ProtoEncode>::encoded_len(
                        &self.known_field,
                    );
        }
        len += self.unknown_fields.len();
        len
    }
}
impl protomon::codec::ProtoDecode for Message {
    #[inline(always)]
    fn decode_into<B: bytes::Buf>(
        buf: &mut B,
        dst: &mut Self,
        _offset: usize,
    ) -> Result<(), protomon::error::DecodeError> {
        use bytes::Buf;
        let len = protomon::wire::decode_len(buf)?;
        if buf.remaining() < len {
            return Err(protomon::error::DecodeError::unexpected_end_of_buffer());
        }
        <Self as protomon::codec::ProtoMessage>::decode_message_into(
            buf.copy_to_bytes(len),
            dst,
        )?;
        Ok(())
    }
}
impl protomon::codec::ProtoEncode for Message {
    #[inline]
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) {
        use protomon::leb128::LebCodec;
        let len = <Self as protomon::codec::ProtoMessage>::encoded_message_len(self);
        (len as u64).encode_leb128(buf);
        <Self as protomon::codec::ProtoMessage>::encode_message(self, buf);
    }
    #[inline]
    fn encoded_len(&self) -> usize {
        use protomon::leb128::LebCodec;
        let len = <Self as protomon::codec::ProtoMessage>::encoded_message_len(self);
        (len as u64).encoded_leb128_len() + len
    }
}
