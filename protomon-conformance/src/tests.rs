//! Conformance tests for protomon.
//!
//! Each test reads a binary protobuf file generated by the C++ protobuf library
//! and verifies that protomon decodes it correctly.

use bytes::Bytes;
use protomon::codec::{Fixed32, Fixed64, ProtoMessage, Sfixed32, Sfixed64, Sint32, Sint64};
use std::path::PathBuf;

use crate::protos::conformance::*;

/// Get the path to the testdata directory.
fn testdata_dir() -> PathBuf {
    PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("testdata")
}

/// Read a binary test file.
fn read_bin(category: &str, name: &str) -> Bytes {
    let path = testdata_dir().join(category).join(format!("{}.bin", name));
    Bytes::from(std::fs::read(&path).unwrap_or_else(|e| panic!("Failed to read {:?}: {}", path, e)))
}

// =============================================================================
// Scalar Tests
// =============================================================================

mod scalars {
    use super::*;

    // --- int32 ---

    #[test]
    fn int32_zero() {
        let data = read_bin("scalars", "int32_zero");
        let msg = Int32Value::decode_message(data).unwrap();
        assert_eq!(msg.value, 0);
    }

    #[test]
    fn int32_one() {
        let data = read_bin("scalars", "int32_one");
        let msg = Int32Value::decode_message(data).unwrap();
        assert_eq!(msg.value, 1);
    }

    #[test]
    fn int32_minus_one() {
        let data = read_bin("scalars", "int32_minus_one");
        let msg = Int32Value::decode_message(data).unwrap();
        assert_eq!(msg.value, -1);
    }

    #[test]
    fn int32_max() {
        let data = read_bin("scalars", "int32_max");
        let msg = Int32Value::decode_message(data).unwrap();
        assert_eq!(msg.value, i32::MAX);
    }

    #[test]
    fn int32_min() {
        let data = read_bin("scalars", "int32_min");
        let msg = Int32Value::decode_message(data).unwrap();
        assert_eq!(msg.value, i32::MIN);
    }

    #[test]
    fn int32_127() {
        let data = read_bin("scalars", "int32_127");
        let msg = Int32Value::decode_message(data).unwrap();
        assert_eq!(msg.value, 127);
    }

    #[test]
    fn int32_128() {
        let data = read_bin("scalars", "int32_128");
        let msg = Int32Value::decode_message(data).unwrap();
        assert_eq!(msg.value, 128);
    }

    // --- int64 ---

    #[test]
    fn int64_zero() {
        let data = read_bin("scalars", "int64_zero");
        let msg = Int64Value::decode_message(data).unwrap();
        assert_eq!(msg.value, 0);
    }

    #[test]
    fn int64_one() {
        let data = read_bin("scalars", "int64_one");
        let msg = Int64Value::decode_message(data).unwrap();
        assert_eq!(msg.value, 1);
    }

    #[test]
    fn int64_minus_one() {
        let data = read_bin("scalars", "int64_minus_one");
        let msg = Int64Value::decode_message(data).unwrap();
        assert_eq!(msg.value, -1);
    }

    #[test]
    fn int64_max() {
        let data = read_bin("scalars", "int64_max");
        let msg = Int64Value::decode_message(data).unwrap();
        assert_eq!(msg.value, i64::MAX);
    }

    #[test]
    fn int64_min() {
        let data = read_bin("scalars", "int64_min");
        let msg = Int64Value::decode_message(data).unwrap();
        assert_eq!(msg.value, i64::MIN);
    }

    #[test]
    fn int64_large() {
        let data = read_bin("scalars", "int64_large");
        let msg = Int64Value::decode_message(data).unwrap();
        assert_eq!(msg.value, 1234567890123456789);
    }

    // --- uint32 ---

    #[test]
    fn uint32_zero() {
        let data = read_bin("scalars", "uint32_zero");
        let msg = Uint32Value::decode_message(data).unwrap();
        assert_eq!(msg.value, 0);
    }

    #[test]
    fn uint32_one() {
        let data = read_bin("scalars", "uint32_one");
        let msg = Uint32Value::decode_message(data).unwrap();
        assert_eq!(msg.value, 1);
    }

    #[test]
    fn uint32_max() {
        let data = read_bin("scalars", "uint32_max");
        let msg = Uint32Value::decode_message(data).unwrap();
        assert_eq!(msg.value, u32::MAX);
    }

    #[test]
    fn uint32_127() {
        let data = read_bin("scalars", "uint32_127");
        let msg = Uint32Value::decode_message(data).unwrap();
        assert_eq!(msg.value, 127);
    }

    #[test]
    fn uint32_128() {
        let data = read_bin("scalars", "uint32_128");
        let msg = Uint32Value::decode_message(data).unwrap();
        assert_eq!(msg.value, 128);
    }

    // --- uint64 ---

    #[test]
    fn uint64_zero() {
        let data = read_bin("scalars", "uint64_zero");
        let msg = Uint64Value::decode_message(data).unwrap();
        assert_eq!(msg.value, 0);
    }

    #[test]
    fn uint64_one() {
        let data = read_bin("scalars", "uint64_one");
        let msg = Uint64Value::decode_message(data).unwrap();
        assert_eq!(msg.value, 1);
    }

    #[test]
    fn uint64_max() {
        let data = read_bin("scalars", "uint64_max");
        let msg = Uint64Value::decode_message(data).unwrap();
        assert_eq!(msg.value, u64::MAX);
    }

    #[test]
    fn uint64_large() {
        let data = read_bin("scalars", "uint64_large");
        let msg = Uint64Value::decode_message(data).unwrap();
        assert_eq!(msg.value, 12345678901234567890);
    }

    // --- sint32 ---

    #[test]
    fn sint32_zero() {
        let data = read_bin("scalars", "sint32_zero");
        let msg = Sint32Value::decode_message(data).unwrap();
        assert_eq!(msg.value, Sint32(0));
    }

    #[test]
    fn sint32_one() {
        let data = read_bin("scalars", "sint32_one");
        let msg = Sint32Value::decode_message(data).unwrap();
        assert_eq!(msg.value, Sint32(1));
    }

    #[test]
    fn sint32_minus_one() {
        let data = read_bin("scalars", "sint32_minus_one");
        let msg = Sint32Value::decode_message(data).unwrap();
        assert_eq!(msg.value, Sint32(-1));
    }

    #[test]
    fn sint32_max() {
        let data = read_bin("scalars", "sint32_max");
        let msg = Sint32Value::decode_message(data).unwrap();
        assert_eq!(msg.value, Sint32(i32::MAX));
    }

    #[test]
    fn sint32_min() {
        let data = read_bin("scalars", "sint32_min");
        let msg = Sint32Value::decode_message(data).unwrap();
        assert_eq!(msg.value, Sint32(i32::MIN));
    }

    // --- sint64 ---

    #[test]
    fn sint64_zero() {
        let data = read_bin("scalars", "sint64_zero");
        let msg = Sint64Value::decode_message(data).unwrap();
        assert_eq!(msg.value, Sint64(0));
    }

    #[test]
    fn sint64_one() {
        let data = read_bin("scalars", "sint64_one");
        let msg = Sint64Value::decode_message(data).unwrap();
        assert_eq!(msg.value, Sint64(1));
    }

    #[test]
    fn sint64_minus_one() {
        let data = read_bin("scalars", "sint64_minus_one");
        let msg = Sint64Value::decode_message(data).unwrap();
        assert_eq!(msg.value, Sint64(-1));
    }

    #[test]
    fn sint64_max() {
        let data = read_bin("scalars", "sint64_max");
        let msg = Sint64Value::decode_message(data).unwrap();
        assert_eq!(msg.value, Sint64(i64::MAX));
    }

    #[test]
    fn sint64_min() {
        let data = read_bin("scalars", "sint64_min");
        let msg = Sint64Value::decode_message(data).unwrap();
        assert_eq!(msg.value, Sint64(i64::MIN));
    }

    // --- bool ---

    #[test]
    fn bool_false() {
        let data = read_bin("scalars", "bool_false");
        let msg = BoolValue::decode_message(data).unwrap();
        assert!(!msg.value);
    }

    #[test]
    fn bool_true() {
        let data = read_bin("scalars", "bool_true");
        let msg = BoolValue::decode_message(data).unwrap();
        assert!(msg.value);
    }

    // --- fixed32 ---

    #[test]
    fn fixed32_zero() {
        let data = read_bin("scalars", "fixed32_zero");
        let msg = Fixed32Value::decode_message(data).unwrap();
        assert_eq!(msg.value, Fixed32(0));
    }

    #[test]
    fn fixed32_one() {
        let data = read_bin("scalars", "fixed32_one");
        let msg = Fixed32Value::decode_message(data).unwrap();
        assert_eq!(msg.value, Fixed32(1));
    }

    #[test]
    fn fixed32_max() {
        let data = read_bin("scalars", "fixed32_max");
        let msg = Fixed32Value::decode_message(data).unwrap();
        assert_eq!(msg.value, Fixed32(u32::MAX));
    }

    // --- sfixed32 ---

    #[test]
    fn sfixed32_zero() {
        let data = read_bin("scalars", "sfixed32_zero");
        let msg = Sfixed32Value::decode_message(data).unwrap();
        assert_eq!(msg.value, Sfixed32(0));
    }

    #[test]
    fn sfixed32_one() {
        let data = read_bin("scalars", "sfixed32_one");
        let msg = Sfixed32Value::decode_message(data).unwrap();
        assert_eq!(msg.value, Sfixed32(1));
    }

    #[test]
    fn sfixed32_minus_one() {
        let data = read_bin("scalars", "sfixed32_minus_one");
        let msg = Sfixed32Value::decode_message(data).unwrap();
        assert_eq!(msg.value, Sfixed32(-1));
    }

    #[test]
    fn sfixed32_max() {
        let data = read_bin("scalars", "sfixed32_max");
        let msg = Sfixed32Value::decode_message(data).unwrap();
        assert_eq!(msg.value, Sfixed32(i32::MAX));
    }

    #[test]
    fn sfixed32_min() {
        let data = read_bin("scalars", "sfixed32_min");
        let msg = Sfixed32Value::decode_message(data).unwrap();
        assert_eq!(msg.value, Sfixed32(i32::MIN));
    }

    // --- fixed64 ---

    #[test]
    fn fixed64_zero() {
        let data = read_bin("scalars", "fixed64_zero");
        let msg = Fixed64Value::decode_message(data).unwrap();
        assert_eq!(msg.value, Fixed64(0));
    }

    #[test]
    fn fixed64_one() {
        let data = read_bin("scalars", "fixed64_one");
        let msg = Fixed64Value::decode_message(data).unwrap();
        assert_eq!(msg.value, Fixed64(1));
    }

    #[test]
    fn fixed64_max() {
        let data = read_bin("scalars", "fixed64_max");
        let msg = Fixed64Value::decode_message(data).unwrap();
        assert_eq!(msg.value, Fixed64(u64::MAX));
    }

    // --- sfixed64 ---

    #[test]
    fn sfixed64_zero() {
        let data = read_bin("scalars", "sfixed64_zero");
        let msg = Sfixed64Value::decode_message(data).unwrap();
        assert_eq!(msg.value, Sfixed64(0));
    }

    #[test]
    fn sfixed64_one() {
        let data = read_bin("scalars", "sfixed64_one");
        let msg = Sfixed64Value::decode_message(data).unwrap();
        assert_eq!(msg.value, Sfixed64(1));
    }

    #[test]
    fn sfixed64_minus_one() {
        let data = read_bin("scalars", "sfixed64_minus_one");
        let msg = Sfixed64Value::decode_message(data).unwrap();
        assert_eq!(msg.value, Sfixed64(-1));
    }

    #[test]
    fn sfixed64_max() {
        let data = read_bin("scalars", "sfixed64_max");
        let msg = Sfixed64Value::decode_message(data).unwrap();
        assert_eq!(msg.value, Sfixed64(i64::MAX));
    }

    #[test]
    fn sfixed64_min() {
        let data = read_bin("scalars", "sfixed64_min");
        let msg = Sfixed64Value::decode_message(data).unwrap();
        assert_eq!(msg.value, Sfixed64(i64::MIN));
    }

    // --- float ---

    #[test]
    fn float_zero() {
        let data = read_bin("scalars", "float_zero");
        let msg = FloatValue::decode_message(data).unwrap();
        assert_eq!(msg.value, 0.0f32);
    }

    #[test]
    fn float_one() {
        let data = read_bin("scalars", "float_one");
        let msg = FloatValue::decode_message(data).unwrap();
        assert_eq!(msg.value, 1.0f32);
    }

    #[test]
    fn float_minus_one() {
        let data = read_bin("scalars", "float_minus_one");
        let msg = FloatValue::decode_message(data).unwrap();
        assert_eq!(msg.value, -1.0f32);
    }

    #[test]
    fn float_pi() {
        let data = read_bin("scalars", "float_pi");
        let msg = FloatValue::decode_message(data).unwrap();
        assert!((msg.value - 3.14159f32).abs() < 1e-5);
    }

    #[test]
    fn float_max() {
        let data = read_bin("scalars", "float_max");
        let msg = FloatValue::decode_message(data).unwrap();
        assert_eq!(msg.value, f32::MAX);
    }

    #[test]
    fn float_min_positive() {
        let data = read_bin("scalars", "float_min_positive");
        let msg = FloatValue::decode_message(data).unwrap();
        assert_eq!(msg.value, f32::MIN_POSITIVE);
    }

    // --- double ---

    #[test]
    fn double_zero() {
        let data = read_bin("scalars", "double_zero");
        let msg = DoubleValue::decode_message(data).unwrap();
        assert_eq!(msg.value, 0.0f64);
    }

    #[test]
    fn double_one() {
        let data = read_bin("scalars", "double_one");
        let msg = DoubleValue::decode_message(data).unwrap();
        assert_eq!(msg.value, 1.0f64);
    }

    #[test]
    fn double_minus_one() {
        let data = read_bin("scalars", "double_minus_one");
        let msg = DoubleValue::decode_message(data).unwrap();
        assert_eq!(msg.value, -1.0f64);
    }

    #[test]
    fn double_pi() {
        let data = read_bin("scalars", "double_pi");
        let msg = DoubleValue::decode_message(data).unwrap();
        assert!((msg.value - 3.141592653589793f64).abs() < 1e-10);
    }

    #[test]
    fn double_max() {
        let data = read_bin("scalars", "double_max");
        let msg = DoubleValue::decode_message(data).unwrap();
        assert_eq!(msg.value, f64::MAX);
    }

    #[test]
    fn double_min_positive() {
        let data = read_bin("scalars", "double_min_positive");
        let msg = DoubleValue::decode_message(data).unwrap();
        assert_eq!(msg.value, f64::MIN_POSITIVE);
    }

    // --- string ---

    #[test]
    fn string_empty() {
        let data = read_bin("scalars", "string_empty");
        let msg = StringValue::decode_message(data).unwrap();
        assert_eq!(msg.value.as_str(), "");
    }

    #[test]
    fn string_hello() {
        let data = read_bin("scalars", "string_hello");
        let msg = StringValue::decode_message(data).unwrap();
        assert_eq!(msg.value.as_str(), "Hello, World!");
    }

    #[test]
    fn string_unicode() {
        let data = read_bin("scalars", "string_unicode");
        let msg = StringValue::decode_message(data).unwrap();
        assert_eq!(msg.value.as_str(), "Hello, \u{4e16}\u{754c}!");
    }

    #[test]
    fn string_escaped() {
        let data = read_bin("scalars", "string_escaped");
        let msg = StringValue::decode_message(data).unwrap();
        assert_eq!(msg.value.as_str(), "line1\nline2\ttab\\backslash\"quote");
    }

    // --- bytes ---

    #[test]
    fn bytes_empty() {
        let data = read_bin("scalars", "bytes_empty");
        let msg = BytesValue::decode_message(data).unwrap();
        assert!(msg.value.is_empty());
    }

    #[test]
    fn bytes_hello() {
        let data = read_bin("scalars", "bytes_hello");
        let msg = BytesValue::decode_message(data).unwrap();
        assert_eq!(msg.value.as_ref(), b"hello");
    }

    #[test]
    fn bytes_binary() {
        let data = read_bin("scalars", "bytes_binary");
        let msg = BytesValue::decode_message(data).unwrap();
        // \000\001\002\377\376\375 in octal = 0, 1, 2, 255, 254, 253
        assert_eq!(msg.value.as_ref(), &[0x00, 0x01, 0x02, 0xff, 0xfe, 0xfd]);
    }

    // --- Combined Scalars ---

    #[test]
    fn scalars_all() {
        let data = read_bin("scalars", "scalars_all");
        let msg = Scalars::decode_message(data).unwrap();
        assert_eq!(msg.val_int32, 42);
        assert_eq!(msg.val_int64, 9876543210);
        assert_eq!(msg.val_uint32, 12345);
        assert_eq!(msg.val_uint64, 18_446_744_073_709_551_615);
        assert_eq!(msg.val_sint32, Sint32(-100));
        assert_eq!(msg.val_sint64, Sint64(-9876543210));
        assert!(msg.val_bool);
        assert_eq!(msg.val_fixed32, Fixed32(0xdeadbeef));
        assert_eq!(msg.val_sfixed32, Sfixed32(-12345));
        assert_eq!(msg.val_fixed64, Fixed64(0xdeadbeefcafebabe));
        assert_eq!(msg.val_sfixed64, Sfixed64(-9876543210));
        assert!((msg.val_float - 3.14159f32).abs() < 1e-4);
        assert!((msg.val_double - 2.718281828459045f64).abs() < 1e-10);
        assert_eq!(msg.val_string.as_str(), "Hello, Protocol Buffers!");
        // "binary\000data" = b"binary\0data"
        assert_eq!(msg.val_bytes.as_ref(), b"binary\0data");
    }

    #[test]
    fn scalars_zeros() {
        let data = read_bin("scalars", "scalars_zeros");
        let msg = Scalars::decode_message(data).unwrap();
        // All fields should be at default (zero) values
        assert_eq!(msg.val_int32, 0);
        assert_eq!(msg.val_int64, 0);
        assert_eq!(msg.val_uint32, 0);
        assert_eq!(msg.val_uint64, 0);
        assert_eq!(msg.val_sint32, Sint32(0));
        assert_eq!(msg.val_sint64, Sint64(0));
        assert!(!msg.val_bool);
        assert_eq!(msg.val_fixed32, Fixed32(0));
        assert_eq!(msg.val_sfixed32, Sfixed32(0));
        assert_eq!(msg.val_fixed64, Fixed64(0));
        assert_eq!(msg.val_sfixed64, Sfixed64(0));
        assert_eq!(msg.val_float, 0.0f32);
        assert_eq!(msg.val_double, 0.0f64);
        assert_eq!(msg.val_string.as_str(), "");
        assert!(msg.val_bytes.is_empty());
    }
}

// =============================================================================
// Repeated Field Tests
// =============================================================================

mod repeated {
    use super::*;

    #[test]
    fn repeated_int32_empty() {
        let data = read_bin("repeated", "repeated_int32_empty");
        let msg = RepeatedInt32::decode_message(data).unwrap();
        assert!(msg.values.is_empty());
    }

    #[test]
    fn repeated_string_empty() {
        let data = read_bin("repeated", "repeated_string_empty");
        let msg = RepeatedString::decode_message(data).unwrap();
        assert!(msg.values.is_empty());
    }

    #[test]
    fn repeated_int32_single() {
        let data = read_bin("repeated", "repeated_int32_single");
        let msg = RepeatedInt32::decode_message(data).unwrap();
        let values: Vec<i32> = msg.values.iter().map(|r| r.unwrap()).collect();
        assert_eq!(values, vec![42]);
    }

    #[test]
    fn repeated_string_single() {
        let data = read_bin("repeated", "repeated_string_single");
        let msg = RepeatedString::decode_message(data).unwrap();
        let values: Vec<_> = msg.values.iter().map(|r| r.unwrap()).collect();
        assert_eq!(values.len(), 1);
        assert_eq!(values[0].as_str(), "hello");
    }

    #[test]
    fn repeated_int32_multiple() {
        let data = read_bin("repeated", "repeated_int32_multiple");
        let msg = RepeatedInt32::decode_message(data).unwrap();
        let values: Vec<i32> = msg.values.iter().map(|r| r.unwrap()).collect();
        assert_eq!(values, vec![1, 2, 3, -1, 127, 128, 255, 256]);
    }

    #[test]
    fn repeated_string_multiple() {
        let data = read_bin("repeated", "repeated_string_multiple");
        let msg = RepeatedString::decode_message(data).unwrap();
        let values: Vec<_> = msg.values.iter().map(|r| r.unwrap()).collect();
        assert_eq!(values.len(), 5);
        assert_eq!(values[0].as_str(), "one");
        assert_eq!(values[1].as_str(), "two");
        assert_eq!(values[2].as_str(), "three");
        assert_eq!(values[3].as_str(), "");
        assert_eq!(values[4].as_str(), "with spaces");
    }

    #[test]
    fn repeated_bytes_multiple() {
        let data = read_bin("repeated", "repeated_bytes_multiple");
        let msg = RepeatedBytes::decode_message(data).unwrap();
        let values: Vec<_> = msg.values.iter().map(|r| r.unwrap()).collect();
        assert_eq!(values.len(), 4);
        assert_eq!(values[0].as_ref(), b"hello");
        assert_eq!(values[1].as_ref(), &[]);
        assert_eq!(values[2].as_ref(), &[0x00, 0x01, 0x02]);
        assert_eq!(values[3].as_ref(), b"world");
    }

    // --- Packed repeated fields ---

    #[test]
    fn repeated_int32_packed() {
        let data = read_bin("repeated", "repeated_int32_packed");
        let msg = RepeatedInt32::decode_message(data).unwrap();
        let values: Vec<i32> = msg.values.decode().unwrap();
        assert_eq!(values, vec![1, 2, 3, -1, 127, 128, i32::MAX, i32::MIN]);
    }

    #[test]
    fn repeated_int64_packed() {
        let data = read_bin("repeated", "repeated_int64_packed");
        let msg = RepeatedInt64::decode_message(data).unwrap();
        let values: Vec<i64> = msg.values.decode().unwrap();
        assert_eq!(values, vec![1, 2, 3, -1, i64::MAX, i64::MIN]);
    }

    #[test]
    fn repeated_uint32_packed() {
        let data = read_bin("repeated", "repeated_uint32_packed");
        let msg = RepeatedUint32::decode_message(data).unwrap();
        let values: Vec<u32> = msg.values.decode().unwrap();
        assert_eq!(values, vec![0, 1, 127, 128, 255, 256, u32::MAX]);
    }

    #[test]
    fn repeated_uint64_packed() {
        let data = read_bin("repeated", "repeated_uint64_packed");
        let msg = RepeatedUint64::decode_message(data).unwrap();
        let values: Vec<u64> = msg.values.decode().unwrap();
        assert_eq!(values, vec![0, 1, 127, 128, u64::MAX]);
    }

    #[test]
    fn repeated_sint32_packed() {
        let data = read_bin("repeated", "repeated_sint32_packed");
        let msg = RepeatedSint32::decode_message(data).unwrap();
        let values: Vec<Sint32> = msg.values.decode().unwrap();
        assert_eq!(
            values,
            vec![
                Sint32(0),
                Sint32(1),
                Sint32(-1),
                Sint32(2),
                Sint32(-2),
                Sint32(i32::MAX),
                Sint32(i32::MIN)
            ]
        );
    }

    #[test]
    fn repeated_sint64_packed() {
        let data = read_bin("repeated", "repeated_sint64_packed");
        let msg = RepeatedSint64::decode_message(data).unwrap();
        let values: Vec<Sint64> = msg.values.decode().unwrap();
        assert_eq!(
            values,
            vec![
                Sint64(0),
                Sint64(1),
                Sint64(-1),
                Sint64(2),
                Sint64(-2),
                Sint64(i64::MAX),
                Sint64(i64::MIN)
            ]
        );
    }

    #[test]
    fn repeated_bool_packed() {
        let data = read_bin("repeated", "repeated_bool_packed");
        let msg = RepeatedBool::decode_message(data).unwrap();
        let values: Vec<bool> = msg.values.decode().unwrap();
        assert_eq!(values, vec![false, true, false, true, true]);
    }

    #[test]
    fn repeated_fixed32_packed() {
        let data = read_bin("repeated", "repeated_fixed32_packed");
        let msg = RepeatedFixed32::decode_message(data).unwrap();
        let values: Vec<Fixed32> = msg.values.decode().unwrap();
        assert_eq!(
            values,
            vec![
                Fixed32(0),
                Fixed32(1),
                Fixed32(255),
                Fixed32(65535),
                Fixed32(u32::MAX)
            ]
        );
    }

    #[test]
    fn repeated_sfixed32_packed() {
        let data = read_bin("repeated", "repeated_sfixed32_packed");
        let msg = RepeatedSfixed32::decode_message(data).unwrap();
        let values: Vec<Sfixed32> = msg.values.decode().unwrap();
        assert_eq!(
            values,
            vec![
                Sfixed32(0),
                Sfixed32(1),
                Sfixed32(-1),
                Sfixed32(i32::MAX),
                Sfixed32(i32::MIN)
            ]
        );
    }

    #[test]
    fn repeated_fixed64_packed() {
        let data = read_bin("repeated", "repeated_fixed64_packed");
        let msg = RepeatedFixed64::decode_message(data).unwrap();
        let values: Vec<Fixed64> = msg.values.decode().unwrap();
        assert_eq!(values, vec![Fixed64(0), Fixed64(1), Fixed64(u64::MAX)]);
    }

    #[test]
    fn repeated_sfixed64_packed() {
        let data = read_bin("repeated", "repeated_sfixed64_packed");
        let msg = RepeatedSfixed64::decode_message(data).unwrap();
        let values: Vec<Sfixed64> = msg.values.decode().unwrap();
        assert_eq!(
            values,
            vec![
                Sfixed64(0),
                Sfixed64(1),
                Sfixed64(-1),
                Sfixed64(i64::MAX),
                Sfixed64(i64::MIN)
            ]
        );
    }

    #[test]
    fn repeated_float_packed() {
        let data = read_bin("repeated", "repeated_float_packed");
        let msg = RepeatedFloat::decode_message(data).unwrap();
        let values: Vec<f32> = msg.values.decode().unwrap();
        assert_eq!(values.len(), 5);
        assert_eq!(values[0], 0.0f32);
        assert_eq!(values[1], 1.0f32);
        assert_eq!(values[2], -1.0f32);
        assert!((values[3] - 3.14159f32).abs() < 1e-4);
        assert_eq!(values[4], f32::MAX);
    }

    #[test]
    fn repeated_double_packed() {
        let data = read_bin("repeated", "repeated_double_packed");
        let msg = RepeatedDouble::decode_message(data).unwrap();
        let values: Vec<f64> = msg.values.decode().unwrap();
        assert_eq!(values.len(), 5);
        assert_eq!(values[0], 0.0f64);
        assert_eq!(values[1], 1.0f64);
        assert_eq!(values[2], -1.0f64);
        assert!((values[3] - 3.141592653589793f64).abs() < 1e-10);
        assert_eq!(values[4], f64::MAX);
    }

    #[test]
    fn repeated_all() {
        let data = read_bin("repeated", "repeated_all");
        let msg = RepeatedScalars::decode_message(data).unwrap();

        let int32s: Vec<i32> = msg.val_int32.decode().unwrap();
        assert_eq!(int32s, vec![1, 2, 3]);

        let int64s: Vec<i64> = msg.val_int64.decode().unwrap();
        assert_eq!(int64s, vec![100, 200, 300]);

        let uint32s: Vec<u32> = msg.val_uint32.decode().unwrap();
        assert_eq!(uint32s, vec![10, 20, 30]);

        let uint64s: Vec<u64> = msg.val_uint64.decode().unwrap();
        assert_eq!(uint64s, vec![1000, 2000, 3000]);

        let sint32s: Vec<Sint32> = msg.val_sint32.decode().unwrap();
        assert_eq!(sint32s, vec![Sint32(-1), Sint32(0), Sint32(1)]);

        let sint64s: Vec<Sint64> = msg.val_sint64.decode().unwrap();
        assert_eq!(sint64s, vec![Sint64(-100), Sint64(0), Sint64(100)]);

        let bools: Vec<bool> = msg.val_bool.decode().unwrap();
        assert_eq!(bools, vec![true, false, true]);

        let fixed32s: Vec<Fixed32> = msg.val_fixed32.decode().unwrap();
        assert_eq!(fixed32s, vec![Fixed32(1), Fixed32(2), Fixed32(3)]);

        let sfixed32s: Vec<Sfixed32> = msg.val_sfixed32.decode().unwrap();
        assert_eq!(sfixed32s, vec![Sfixed32(-1), Sfixed32(0), Sfixed32(1)]);

        let fixed64s: Vec<Fixed64> = msg.val_fixed64.decode().unwrap();
        assert_eq!(fixed64s, vec![Fixed64(100), Fixed64(200), Fixed64(300)]);

        let sfixed64s: Vec<Sfixed64> = msg.val_sfixed64.decode().unwrap();
        assert_eq!(sfixed64s, vec![Sfixed64(-100), Sfixed64(0), Sfixed64(100)]);

        let floats: Vec<f32> = msg.val_float.decode().unwrap();
        assert_eq!(floats, vec![1.0f32, 2.0f32, 3.0f32]);

        let doubles: Vec<f64> = msg.val_double.decode().unwrap();
        assert_eq!(doubles.len(), 3);
        assert!((doubles[0] - 1.1f64).abs() < 1e-10);
        assert!((doubles[1] - 2.2f64).abs() < 1e-10);
        assert!((doubles[2] - 3.3f64).abs() < 1e-10);

        let strings: Vec<_> = msg.val_string.iter().map(|r| r.unwrap()).collect();
        assert_eq!(strings.len(), 3);
        assert_eq!(strings[0].as_str(), "one");
        assert_eq!(strings[1].as_str(), "two");
        assert_eq!(strings[2].as_str(), "three");

        let bytes_vals: Vec<_> = msg.val_bytes.iter().map(|r| r.unwrap()).collect();
        assert_eq!(bytes_vals.len(), 3);
        assert_eq!(bytes_vals[0].as_ref(), b"a");
        assert_eq!(bytes_vals[1].as_ref(), b"b");
        assert_eq!(bytes_vals[2].as_ref(), b"c");
    }
}

// =============================================================================
// Nested Message Tests
// =============================================================================

mod nested {
    use super::*;

    #[test]
    fn nested_empty() {
        let data = read_bin("nested", "nested_empty");
        let msg = Outer::decode_message(data).unwrap();
        // Empty message - all defaults
        assert_eq!(msg.id, 0);
        // In proto3, submessage field is None when not present
        assert!(msg.inner.is_none() || msg.inner.as_ref().map(|i| i.value == 0 && i.name.as_str() == "").unwrap_or(false));
        assert!(msg.items.is_empty());
    }

    #[test]
    fn nested_simple() {
        let data = read_bin("nested", "nested_simple");
        let msg = Outer::decode_message(data).unwrap();
        assert_eq!(msg.id, 1);
        let inner = msg.inner.as_ref().unwrap();
        assert_eq!(inner.value, 42);
        assert_eq!(inner.name.as_str(), "nested");
    }

    #[test]
    fn nested_with_repeated() {
        let data = read_bin("nested", "nested_with_repeated");
        let msg = Outer::decode_message(data).unwrap();
        assert_eq!(msg.id, 100);
        let inner = msg.inner.as_ref().unwrap();
        assert_eq!(inner.value, 1);
        assert_eq!(inner.name.as_str(), "first");

        let items: Vec<_> = msg.items.iter().map(|r| r.unwrap()).collect();
        assert_eq!(items.len(), 3);
        assert_eq!(items[0].value, 10);
        assert_eq!(items[0].name.as_str(), "item1");
        assert_eq!(items[1].value, 20);
        assert_eq!(items[1].name.as_str(), "item2");
        assert_eq!(items[2].value, 30);
        assert_eq!(items[2].name.as_str(), "item3");
    }

    #[test]
    fn deep_level0_only() {
        let data = read_bin("nested", "deep_level0_only");
        let msg = Level0::decode_message(data).unwrap();
        assert_eq!(msg.value, 0);
    }

    #[test]
    fn deep_all_levels() {
        let data = read_bin("nested", "deep_all_levels");
        let msg = Level0::decode_message(data).unwrap();
        assert_eq!(msg.value, 0);
        let level1 = msg.next.as_ref().unwrap();
        assert_eq!(level1.value, 1);
        let level2 = level1.next.as_ref().unwrap();
        assert_eq!(level2.value, 2);
        let level3 = level2.next.as_ref().unwrap();
        assert_eq!(level3.value, 3);
    }

    #[test]
    fn node_leaf() {
        let data = read_bin("nested", "node_leaf");
        let msg = Node::decode_message(data).unwrap();
        assert_eq!(msg.id, 1);
        assert_eq!(msg.label.as_str(), "leaf");
        assert!(msg.children.is_empty());
    }

    #[test]
    fn node_with_children() {
        let data = read_bin("nested", "node_with_children");
        let msg = Node::decode_message(data).unwrap();
        assert_eq!(msg.id, 1);
        assert_eq!(msg.label.as_str(), "root");

        let children: Vec<_> = msg.children.iter().map(|r| r.unwrap()).collect();
        assert_eq!(children.len(), 2);
        assert_eq!(children[0].id, 2);
        assert_eq!(children[0].label.as_str(), "child1");
        assert_eq!(children[1].id, 3);
        assert_eq!(children[1].label.as_str(), "child2");
    }

    #[test]
    fn node_deep_tree() {
        let data = read_bin("nested", "node_deep_tree");
        let msg = Node::decode_message(data).unwrap();
        assert_eq!(msg.id, 1);
        assert_eq!(msg.label.as_str(), "root");

        let level1: Vec<_> = msg.children.iter().map(|r| r.unwrap()).collect();
        assert_eq!(level1.len(), 1);
        assert_eq!(level1[0].id, 2);
        assert_eq!(level1[0].label.as_str(), "level1");

        let level2: Vec<_> = level1[0].children.iter().map(|r| r.unwrap()).collect();
        assert_eq!(level2.len(), 1);
        assert_eq!(level2[0].id, 3);
        assert_eq!(level2[0].label.as_str(), "level2");

        let level3: Vec<_> = level2[0].children.iter().map(|r| r.unwrap()).collect();
        assert_eq!(level3.len(), 1);
        assert_eq!(level3[0].id, 4);
        assert_eq!(level3[0].label.as_str(), "level3");
    }

    #[test]
    fn optional_absent() {
        let data = read_bin("nested", "optional_absent");
        let msg = OptionalNested::decode_message(data).unwrap();
        assert!(msg.payload.is_none());
    }

    #[test]
    fn optional_present() {
        let data = read_bin("nested", "optional_present");
        let msg = OptionalNested::decode_message(data).unwrap();
        assert!(msg.payload.is_some());
        assert_eq!(msg.payload.as_ref().unwrap().value, 42);
    }

    #[test]
    fn optional_empty_payload() {
        let data = read_bin("nested", "optional_empty_payload");
        let msg = OptionalNested::decode_message(data).unwrap();
        // Payload is present (not None), but has default values
        assert!(msg.payload.is_some());
        assert_eq!(msg.payload.as_ref().unwrap().value, 0);
    }
}

// =============================================================================
// Edge Case Tests
// =============================================================================

mod edge_cases {
    use super::*;

    #[test]
    fn field_numbers_all() {
        let data = read_bin("edge_cases", "field_numbers_all");
        let msg = FieldNumbers::decode_message(data).unwrap();
        assert_eq!(msg.field_1, 1);
        assert_eq!(msg.field_15, 15);
        assert_eq!(msg.field_16, 16);
        assert_eq!(msg.field_2047, 2047);
        assert_eq!(msg.field_2048, 2048);
        assert_eq!(msg.field_max, 536870911);
    }

    #[test]
    fn field_numbers_min() {
        let data = read_bin("edge_cases", "field_numbers_min");
        let msg = FieldNumbers::decode_message(data).unwrap();
        assert_eq!(msg.field_1, 1);
        // Other fields should be default (0)
        assert_eq!(msg.field_15, 0);
        assert_eq!(msg.field_16, 0);
    }

    #[test]
    fn field_numbers_max() {
        let data = read_bin("edge_cases", "field_numbers_max");
        let msg = FieldNumbers::decode_message(data).unwrap();
        assert_eq!(msg.field_max, 999999999);
        // Other fields should be default (0)
        assert_eq!(msg.field_1, 0);
    }

    #[test]
    fn wire_types_all() {
        let data = read_bin("edge_cases", "wire_types_all");
        let msg = WireTypes::decode_message(data).unwrap();

        // Varint (wire type 0)
        assert_eq!(msg.varint_int32, 42);
        assert_eq!(msg.varint_int64, 9876543210);
        assert_eq!(msg.varint_uint32, 12345);
        assert_eq!(msg.varint_uint64, 18_446_744_073_709_551_615);
        assert_eq!(msg.varint_sint32, Sint32(-100));
        assert_eq!(msg.varint_sint64, Sint64(-9876543210));
        assert!(msg.varint_bool);

        // 64-bit (wire type 1)
        assert_eq!(msg.i64_fixed64, Fixed64(0xdeadbeefcafebabe));
        assert_eq!(msg.i64_sfixed64, Sfixed64(-9876543210));
        assert!((msg.i64_double - 3.141592653589793f64).abs() < 1e-10);

        // Length-delimited (wire type 2)
        assert_eq!(msg.len_string.as_str(), "hello world");
        assert_eq!(msg.len_bytes.as_ref(), &[0x00, 0x01, 0x02, 0x03]);
        assert_eq!(msg.len_message.as_ref().unwrap().value, 42);
        let packed: Vec<i32> = msg.len_packed.iter().map(|r| r.unwrap()).collect();
        assert_eq!(packed, vec![1, 2, 3, 4, 5]);

        // 32-bit (wire type 5)
        assert_eq!(msg.i32_fixed32, Fixed32(0xdeadbeef));
        assert_eq!(msg.i32_sfixed32, Sfixed32(-12345));
        assert!((msg.i32_float - 3.14159f32).abs() < 1e-4);
    }

    #[test]
    fn empty() {
        let data = read_bin("edge_cases", "empty");
        let _msg = Empty::decode_message(data).unwrap();
        // Just verify it decodes without error
    }

    #[test]
    fn all_defaults() {
        let data = read_bin("edge_cases", "all_defaults");
        let msg = AllDefaults::decode_message(data).unwrap();
        assert_eq!(msg.zero_int, 0);
        assert_eq!(msg.empty_string.as_str(), "");
        assert!(!msg.false_bool);
        assert_eq!(msg.zero_double, 0.0f64);
    }

    #[test]
    fn optional_all_absent() {
        let data = read_bin("edge_cases", "optional_all_absent");
        let msg = OptionalFields::decode_message(data).unwrap();
        assert!(msg.opt_int32.is_none());
        assert!(msg.opt_string.is_none());
        assert!(msg.opt_bool.is_none());
    }

    #[test]
    fn optional_all_present() {
        let data = read_bin("edge_cases", "optional_all_present");
        let msg = OptionalFields::decode_message(data).unwrap();
        assert_eq!(msg.opt_int32, Some(42));
        assert!(msg.opt_string.is_some());
        assert_eq!(msg.opt_string.as_ref().unwrap().as_str(), "hello");
        assert_eq!(msg.opt_bool, Some(true));
    }

    #[test]
    fn optional_int_only() {
        let data = read_bin("edge_cases", "optional_int_only");
        let msg = OptionalFields::decode_message(data).unwrap();
        assert_eq!(msg.opt_int32, Some(0));
        assert!(msg.opt_string.is_none());
        assert!(msg.opt_bool.is_none());
    }
}
